commit 3e0f75114f52064d93b135401f800a2be4ddecfe
Author: 王茂斌10268518 <wang.maobin@zte.com.cn>
Date:   Mon Jun 3 15:41:49 2024 +0800

    完成ushell自动完成

diff --git a/Cargo.lock b/Cargo.lock
index 868281b..737a12d 100644
--- a/Cargo.lock
+++ b/Cargo.lock
@@ -2,12 +2,56 @@
 # It is not intended for manual editing.
 version = 3
 
+[[package]]
+name = "aho-corasick"
+version = "1.1.3"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "8e60d3430d3a69478ad0993f19238d2df97c507009a52b3c10addcd7f6bcb916"
+dependencies = [
+ "memchr",
+]
+
+[[package]]
+name = "arrayref"
+version = "0.3.7"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "6b4930d2cb77ce62f89ee5d5289b4ac049559b1c45539271f5ed4fdc7db34545"
+
+[[package]]
+name = "arrayvec"
+version = "0.5.2"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "23b62fc65de8e4e7f52534fb52b0f3ed04746ae267519eef2a83941e8085068b"
+
+[[package]]
+name = "base64"
+version = "0.13.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "9e1b586273c5702936fe7b7d6896644d8be71e6314cfe09d3167c95f712589e8"
+
+[[package]]
+name = "bitflags"
+version = "1.3.2"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "bef38d45163c2f1dde094a7dfd33ccf595c92905c8f8f4fdc18d06fb1037718a"
+
 [[package]]
 name = "bitflags"
 version = "2.5.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "cf4b9d6a944f767f8e5e0db018570623c85f3d925ac718db4e06d0187adb21c1"
 
+[[package]]
+name = "blake2b_simd"
+version = "0.5.11"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "afa748e348ad3be8263be728124b24a24f268266f6f5d58af9d75f6a40b5c587"
+dependencies = [
+ "arrayref",
+ "arrayvec",
+ "constant_time_eq",
+]
+
 [[package]]
 name = "cfg-if"
 version = "1.0.0"
@@ -15,62 +59,88 @@ source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "baf1de4339761588bc0619e3cbc0120ee582ebb74b53b4efbf79117bd2da40fd"
 
 [[package]]
-name = "cfg_aliases"
-version = "0.1.1"
+name = "constant_time_eq"
+version = "0.1.5"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "fd16c4719339c4530435d38e511904438d07cce7950afa3718a84ac36c10e89e"
+checksum = "245097e9a4535ee1e3e3931fcfcd55a796a44c643e8596ff6566d68f09b87bbc"
 
 [[package]]
-name = "clipboard-win"
-version = "5.3.1"
+name = "crossbeam-utils"
+version = "0.8.20"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "79f4473f5144e20d9aceaf2972478f06ddf687831eafeeb434fbaf0acc4144ad"
+checksum = "22ec99545bb0ed0ea7bb9b8e1e9122ea386ff8a48c0922e43f36d45ab09e0e80"
+
+[[package]]
+name = "dirs"
+version = "1.0.5"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "3fd78930633bd1c6e35c4b42b1df7b0cbc6bc191146e512bb3bedf243fcc3901"
 dependencies = [
- "error-code",
+ "libc",
+ "redox_users 0.3.5",
+ "winapi",
 ]
 
 [[package]]
-name = "endian-type"
-version = "0.1.2"
+name = "dirs"
+version = "4.0.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "c34f04666d835ff5d62e058c3995147c06f42fe86ff053337632bca83e42702d"
+checksum = "ca3aa72a6f96ea37bbc5aa912f6788242832f75369bdfdadcb0e38423f100059"
+dependencies = [
+ "dirs-sys",
+]
 
 [[package]]
-name = "errno"
-version = "0.3.9"
+name = "dirs-sys"
+version = "0.3.7"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "534c5cf6194dfab3db3242765c03bbe257cf92f22b38f6bc0c58d59108a820ba"
+checksum = "1b1d1d91c932ef41c0f2663aa8b0ca0342d444d842c06914aa0a7e352d0bada6"
 dependencies = [
  "libc",
- "windows-sys",
+ "redox_users 0.4.5",
+ "winapi",
 ]
 
 [[package]]
-name = "error-code"
-version = "3.2.0"
+name = "fnv"
+version = "1.0.7"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "a0474425d51df81997e2f90a21591180b38eccf27292d755f3e30750225c175b"
+checksum = "3f9eec918d3f24069decb9af1554cad7c880e2da24a9afd88aca000531ab82c1"
 
 [[package]]
-name = "fd-lock"
-version = "4.0.2"
+name = "getrandom"
+version = "0.1.16"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "7e5768da2206272c81ef0b5e951a41862938a6070da63bcea197899942d3b947"
+checksum = "8fc3cb4d91f53b50155bdcfd23f6a4c39ae1969c2ae85982b135750cccaf5fce"
 dependencies = [
  "cfg-if",
- "rustix",
- "windows-sys",
+ "libc",
+ "wasi 0.9.0+wasi-snapshot-preview1",
 ]
 
 [[package]]
-name = "home"
-version = "0.5.9"
+name = "getrandom"
+version = "0.2.15"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "e3d1354bf6b7235cb4a0576c2619fd4ed18183f689b12b006a0ee7329eeff9a5"
+checksum = "c4567c8db10ae91089c99af84c68c38da3ec2f087c3f82960bcdbf3656b6f4d7"
 dependencies = [
- "windows-sys",
+ "cfg-if",
+ "libc",
+ "wasi 0.11.0+wasi-snapshot-preview1",
 ]
 
+[[package]]
+name = "json"
+version = "0.12.4"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "078e285eafdfb6c4b434e0d31e8cfcb5115b651496faca5749b88fafd4f23bfd"
+
+[[package]]
+name = "lazy_static"
+version = "1.4.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "e2abad23fbc42b3700f2f279844dc832adb2b2eb069b2df918f455c4e18cc646"
+
 [[package]]
 name = "libc"
 version = "0.2.155"
@@ -78,16 +148,25 @@ source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "97b3888a4aecf77e811145cadf6eef5901f4782c53886191b2f693f24761847c"
 
 [[package]]
-name = "linux-raw-sys"
-version = "0.4.14"
+name = "libredox"
+version = "0.1.3"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "78b3ae25bc7c8c38cec158d1f2757ee79e9b3740fbc7ccf0e59e4b08d793fa89"
+checksum = "c0ff37bd590ca25063e35af745c343cb7a0271906fb7b37e4813e8f79f00268d"
+dependencies = [
+ "bitflags 2.5.0",
+ "libc",
+]
 
 [[package]]
-name = "log"
-version = "0.4.21"
+name = "linefeed"
+version = "0.6.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "90ed8c1e510134f979dbc4f070f87d4313098b704861a105fe34231c70a3901c"
+checksum = "28715d08e35c6c074f9ae6b2e6a2420bac75d050c66ecd669d7d5b98e2caa036"
+dependencies = [
+ "dirs 1.0.5",
+ "mortal",
+ "winapi",
+]
 
 [[package]]
 name = "memchr"
@@ -96,76 +175,196 @@ source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "6c8640c5d730cb13ebd907d8d04b52f55ac9a2eec55b440c8892f40d56c76c1d"
 
 [[package]]
-name = "nibble_vec"
-version = "0.1.0"
+name = "minimal-lexical"
+version = "0.2.1"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "77a5d83df9f36fe23f0c3648c6bbb8b0298bb5f1939c8f2704431371f4b84d43"
+checksum = "68354c5c6bd36d73ff3feceb05efa59b6acb7626617f4962be322a825e61f79a"
+
+[[package]]
+name = "mortal"
+version = "0.2.4"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "2c624fa1b7aab6bd2aff6e9b18565cc0363b6d45cbcd7465c9ed5e3740ebf097"
 dependencies = [
- "smallvec",
+ "bitflags 2.5.0",
+ "libc",
+ "nix",
+ "smallstr",
+ "terminfo",
+ "unicode-normalization",
+ "unicode-width",
+ "winapi",
 ]
 
 [[package]]
 name = "nix"
-version = "0.28.0"
+version = "0.26.4"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "ab2156c4fce2f8df6c499cc1c763e4394b7482525bf2a9701c9d79d215f519e4"
+checksum = "598beaf3cc6fdd9a5dfb1630c2800c7acd31df7aaf0f565796fba2b53ca1af1b"
 dependencies = [
- "bitflags",
+ "bitflags 1.3.2",
  "cfg-if",
- "cfg_aliases",
  "libc",
 ]
 
 [[package]]
-name = "radix_trie"
-version = "0.2.1"
+name = "nom"
+version = "7.1.3"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "c069c179fcdc6a2fe24d8d18305cf085fdbd4f922c041943e203685d6a1c58fd"
+checksum = "d273983c5a657a70a3e8f2a01329822f3b8c8172b73826411a55751e404a0a4a"
 dependencies = [
- "endian-type",
- "nibble_vec",
+ "memchr",
+ "minimal-lexical",
 ]
 
 [[package]]
-name = "rustix"
-version = "0.38.34"
+name = "phf"
+version = "0.11.2"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "70dc5ec042f7a43c4a73241207cecc9873a06d45debb38b329f8541d85c2730f"
+checksum = "ade2d8b8f33c7333b51bcf0428d37e217e9f32192ae4772156f65063b8ce03dc"
 dependencies = [
- "bitflags",
- "errno",
- "libc",
- "linux-raw-sys",
- "windows-sys",
+ "phf_shared",
 ]
 
 [[package]]
-name = "rustyline"
-version = "14.0.0"
+name = "phf_codegen"
+version = "0.11.2"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "7803e8936da37efd9b6d4478277f4b2b9bb5cdb37a113e8d63222e58da647e63"
+checksum = "e8d39688d359e6b34654d328e262234662d16cc0f60ec8dcbe5e718709342a5a"
 dependencies = [
- "bitflags",
- "cfg-if",
- "clipboard-win",
- "fd-lock",
- "home",
- "libc",
- "log",
+ "phf_generator",
+ "phf_shared",
+]
+
+[[package]]
+name = "phf_generator"
+version = "0.11.2"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "48e4cc64c2ad9ebe670cb8fd69dd50ae301650392e81c05f9bfcb2d5bdbc24b0"
+dependencies = [
+ "phf_shared",
+ "rand",
+]
+
+[[package]]
+name = "phf_shared"
+version = "0.11.2"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "90fcb95eef784c2ac79119d1dd819e162b5da872ce6f3c3abe1e8ca1c082f72b"
+dependencies = [
+ "siphasher",
+]
+
+[[package]]
+name = "proc-macro2"
+version = "1.0.84"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "ec96c6a92621310b51366f1e28d05ef11489516e93be030060e5fc12024a49d6"
+dependencies = [
+ "unicode-ident",
+]
+
+[[package]]
+name = "quote"
+version = "1.0.36"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "0fa76aaf39101c457836aec0ce2316dbdc3ab723cdda1c6bd4e6ad4208acaca7"
+dependencies = [
+ "proc-macro2",
+]
+
+[[package]]
+name = "rand"
+version = "0.8.5"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "34af8d1a0e25924bc5b7c43c079c942339d8f0a8b57c39049bef581b46327404"
+dependencies = [
+ "rand_core",
+]
+
+[[package]]
+name = "rand_core"
+version = "0.6.4"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "ec0be4795e2f6a28069bec0b5ff3e2ac9bafc99e6a9a7dc3547996c5c816922c"
+
+[[package]]
+name = "redox_syscall"
+version = "0.1.57"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "41cc0f7e4d5d4544e8861606a285bb08d3e70712ccc7d2b84d7c0ccfaf4b05ce"
+
+[[package]]
+name = "redox_users"
+version = "0.3.5"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "de0737333e7a9502c789a36d7c7fa6092a49895d4faa31ca5df163857ded2e9d"
+dependencies = [
+ "getrandom 0.1.16",
+ "redox_syscall",
+ "rust-argon2",
+]
+
+[[package]]
+name = "redox_users"
+version = "0.4.5"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "bd283d9651eeda4b2a83a43c1c91b266c40fd76ecd39a50a8c630ae69dc72891"
+dependencies = [
+ "getrandom 0.2.15",
+ "libredox",
+ "thiserror",
+]
+
+[[package]]
+name = "regex"
+version = "1.10.4"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "c117dbdfde9c8308975b6a18d71f3f385c89461f7b3fb054288ecf2a2058ba4c"
+dependencies = [
+ "aho-corasick",
  "memchr",
- "nix",
- "radix_trie",
- "unicode-segmentation",
- "unicode-width",
- "utf8parse",
- "windows-sys",
+ "regex-automata",
+ "regex-syntax",
+]
+
+[[package]]
+name = "regex-automata"
+version = "0.4.6"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "86b83b8b9847f9bf95ef68afb0b8e6cdb80f498442f5179a29fad448fcc1eaea"
+dependencies = [
+ "aho-corasick",
+ "memchr",
+ "regex-syntax",
+]
+
+[[package]]
+name = "regex-syntax"
+version = "0.8.3"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "adad44e29e4c806119491a7f06f03de4d1af22c3a680dd47f1e6e179439d1f56"
+
+[[package]]
+name = "rust-argon2"
+version = "0.8.3"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "4b18820d944b33caa75a71378964ac46f58517c92b6ae5f762636247c09e78fb"
+dependencies = [
+ "base64",
+ "blake2b_simd",
+ "constant_time_eq",
+ "crossbeam-utils",
 ]
 
 [[package]]
 name = "shell_client"
 version = "0.1.0"
 dependencies = [
- "rustyline",
+ "json",
+ "lazy_static",
+ "linefeed",
+ "regex",
  "shell_core",
 ]
 
@@ -181,6 +380,21 @@ dependencies = [
  "shell_core",
 ]
 
+[[package]]
+name = "siphasher"
+version = "0.3.11"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "38b58827f4464d87d377d175e90bf58eb00fd8716ff0a62f80356b5e61555d0d"
+
+[[package]]
+name = "smallstr"
+version = "0.2.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "1e922794d168678729ffc7e07182721a14219c65814e66e91b839a272fe5ae4f"
+dependencies = [
+ "smallvec",
+]
+
 [[package]]
 name = "smallvec"
 version = "1.13.2"
@@ -188,92 +402,115 @@ source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "3c5e1a9a646d36c3599cd173a41282daf47c44583ad367b8e6837255952e5c67"
 
 [[package]]
-name = "unicode-segmentation"
-version = "1.11.0"
+name = "syn"
+version = "2.0.66"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "d4c87d22b6e3f4a18d4d40ef354e97c90fcb14dd91d7dc0aa9d8a1172ebf7202"
+checksum = "c42f3f41a2de00b01c0aaad383c5a45241efc8b2d1eda5661812fda5f3cdcff5"
+dependencies = [
+ "proc-macro2",
+ "quote",
+ "unicode-ident",
+]
 
 [[package]]
-name = "unicode-width"
-version = "0.1.12"
+name = "terminfo"
+version = "0.8.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "68f5e5f3158ecfd4b8ff6fe086db7c8467a2dfdac97fe420f2b7c4aa97af66d6"
+checksum = "666cd3a6681775d22b200409aad3b089c5b99fb11ecdd8a204d9d62f8148498f"
+dependencies = [
+ "dirs 4.0.0",
+ "fnv",
+ "nom",
+ "phf",
+ "phf_codegen",
+]
 
 [[package]]
-name = "utf8parse"
-version = "0.2.1"
+name = "thiserror"
+version = "1.0.61"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "711b9620af191e0cdc7468a8d14e709c3dcdb115b36f838e601583af800a370a"
+checksum = "c546c80d6be4bc6a00c0f01730c08df82eaa7a7a61f11d656526506112cc1709"
+dependencies = [
+ "thiserror-impl",
+]
 
 [[package]]
-name = "windows-sys"
-version = "0.52.0"
+name = "thiserror-impl"
+version = "1.0.61"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "282be5f36a8ce781fad8c8ae18fa3f9beff57ec1b52cb3de0789201425d9a33d"
+checksum = "46c3384250002a6d5af4d114f2845d37b57521033f30d5c3f46c4d70e1197533"
 dependencies = [
- "windows-targets",
+ "proc-macro2",
+ "quote",
+ "syn",
 ]
 
 [[package]]
-name = "windows-targets"
-version = "0.52.5"
+name = "tinyvec"
+version = "1.6.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "6f0713a46559409d202e70e28227288446bf7841d3211583a4b53e3f6d96e7eb"
+checksum = "87cc5ceb3875bb20c2890005a4e226a4651264a5c75edb2421b52861a0a0cb50"
 dependencies = [
- "windows_aarch64_gnullvm",
- "windows_aarch64_msvc",
- "windows_i686_gnu",
- "windows_i686_gnullvm",
- "windows_i686_msvc",
- "windows_x86_64_gnu",
- "windows_x86_64_gnullvm",
- "windows_x86_64_msvc",
+ "tinyvec_macros",
 ]
 
 [[package]]
-name = "windows_aarch64_gnullvm"
-version = "0.52.5"
+name = "tinyvec_macros"
+version = "0.1.1"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "7088eed71e8b8dda258ecc8bac5fb1153c5cffaf2578fc8ff5d61e23578d3263"
+checksum = "1f3ccbac311fea05f86f61904b462b55fb3df8837a366dfc601a0161d0532f20"
 
 [[package]]
-name = "windows_aarch64_msvc"
-version = "0.52.5"
+name = "unicode-ident"
+version = "1.0.12"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "9985fd1504e250c615ca5f281c3f7a6da76213ebd5ccc9561496568a2752afb6"
+checksum = "3354b9ac3fae1ff6755cb6db53683adb661634f67557942dea4facebec0fee4b"
 
 [[package]]
-name = "windows_i686_gnu"
-version = "0.52.5"
+name = "unicode-normalization"
+version = "0.1.23"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "88ba073cf16d5372720ec942a8ccbf61626074c6d4dd2e745299726ce8b89670"
+checksum = "a56d1686db2308d901306f92a263857ef59ea39678a5458e7cb17f01415101f5"
+dependencies = [
+ "tinyvec",
+]
 
 [[package]]
-name = "windows_i686_gnullvm"
-version = "0.52.5"
+name = "unicode-width"
+version = "0.1.12"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "87f4261229030a858f36b459e748ae97545d6f1ec60e5e0d6a3d32e0dc232ee9"
+checksum = "68f5e5f3158ecfd4b8ff6fe086db7c8467a2dfdac97fe420f2b7c4aa97af66d6"
 
 [[package]]
-name = "windows_i686_msvc"
-version = "0.52.5"
+name = "wasi"
+version = "0.9.0+wasi-snapshot-preview1"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "db3c2bf3d13d5b658be73463284eaf12830ac9a26a90c717b7f771dfe97487bf"
+checksum = "cccddf32554fecc6acb585f82a32a72e28b48f8c4c1883ddfeeeaa96f7d8e519"
 
 [[package]]
-name = "windows_x86_64_gnu"
-version = "0.52.5"
+name = "wasi"
+version = "0.11.0+wasi-snapshot-preview1"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "4e4246f76bdeff09eb48875a0fd3e2af6aada79d409d33011886d3e1581517d9"
+checksum = "9c8d87e72b64a3b4db28d11ce29237c246188f4f51057d65a7eab63b7987e423"
+
+[[package]]
+name = "winapi"
+version = "0.3.9"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "5c839a674fcd7a98952e593242ea400abe93992746761e38641405d28b00f419"
+dependencies = [
+ "winapi-i686-pc-windows-gnu",
+ "winapi-x86_64-pc-windows-gnu",
+]
 
 [[package]]
-name = "windows_x86_64_gnullvm"
-version = "0.52.5"
+name = "winapi-i686-pc-windows-gnu"
+version = "0.4.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "852298e482cd67c356ddd9570386e2862b5673c85bd5f88df9ab6802b334c596"
+checksum = "ac3b87c63620426dd9b991e5ce0329eff545bccbbb34f3be09ff6fb6ab51b7b6"
 
 [[package]]
-name = "windows_x86_64_msvc"
-version = "0.52.5"
+name = "winapi-x86_64-pc-windows-gnu"
+version = "0.4.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "bec47e5bfd1bff0eeaf6d8b485cc1074891a197ab4225d504cb7a1ab88b02bf0"
+checksum = "712e227841d057c1ee1cd2fb22fa7e5a5461ae8e48fa2ca79ec42cfc1931183f"
diff --git a/shell_client/Cargo.toml b/shell_client/Cargo.toml
index d2e06f4..57f1bb6 100644
--- a/shell_client/Cargo.toml
+++ b/shell_client/Cargo.toml
@@ -4,5 +4,8 @@ version = "0.1.0"
 edition = "2021"
 
 [dependencies]
-rustyline = "14.0.0"
-shell_core={path= "../shell_core"}
\ No newline at end of file
+linefeed = "0.6.0"
+shell_core={path= "../shell_core"}
+regex="^1"
+lazy_static="1.4.0"
+json = "0.12.4"
\ No newline at end of file
diff --git a/shell_client/src/autocomplete_reader.rs b/shell_client/src/autocomplete_reader.rs
new file mode 100644
index 0000000..50ddedf
--- /dev/null
+++ b/shell_client/src/autocomplete_reader.rs
@@ -0,0 +1,77 @@
+//! 支持自动完成的读取器，输入过程中使用tab可以出发自动完成
+use crate::completer::UshellCompleter;
+use core::time::Duration;
+use linefeed::{terminal::DefaultTerminal, Interface, ReadResult};
+use std::sync::{Arc, Mutex};
+use std::thread::sleep;
+
+/// 自动完成读取器
+/// - interface 读取接口，见linefeed库
+/// - completer 自动完成器
+pub struct AutoCompleteReader {
+    interface: Interface<DefaultTerminal>,
+    completer: Arc<UshellCompleter>,
+}
+
+impl AutoCompleteReader {
+    pub fn read(&self) -> Result<String, String> {
+        sleep(Duration::from_millis(10));
+        match self
+            .interface
+            .read_line()
+            .map_err(|err| format!("read error : {}", err))?
+        {
+            ReadResult::Input(line) => {
+                if !line.trim().is_empty() {
+                    self.interface.add_history(line.clone());
+                }
+                return Ok(line);
+            }
+            ReadResult::Eof => {
+                return Ok("".to_owned());
+            }
+            ReadResult::Signal(s) => {
+                return Err(format!("recv signal {:?}", s));
+            }
+        }
+    }
+    pub fn set_debug_command_complete_data(&mut self, data: Vec<(String, String)>) {
+        self.completer.set_autocomplete_data(data);
+    }
+    pub fn append_debug_command_complete_data(&mut self, data: Vec<(String, String)>) {
+        self.completer.append_complete_data(data);
+    }
+    pub fn set_prompt(&mut self, p: &str) {
+        self.interface.set_prompt(&p).expect("set prompt failed");
+    }
+}
+
+/// 完成器的注册接口
+#[macro_export]
+macro_rules! reg_completer {
+    ($($t:ty),*) => {
+        vec![
+            $(
+            (
+                <$t>::filter as fn(&str, &str) -> bool,
+                <$t>::new(),
+            ),
+            )*
+        ]
+    };
+}
+
+impl AutoCompleteReader {
+    /// 创建读取器
+    pub fn new() -> Result<Arc<Mutex<Box<AutoCompleteReader>>>, String> {
+        let mut ret = Box::<AutoCompleteReader>::new(AutoCompleteReader {
+            interface: Interface::new("ushell-rust").expect("create interface failed"),
+            completer: UshellCompleter::new(),
+        });
+
+        ret.set_prompt(">> ");
+        ret.interface.set_completer(ret.completer.clone());
+
+        Ok(Arc::new(Mutex::new(ret)))
+    }
+}
diff --git a/shell_client/src/client.rs b/shell_client/src/client.rs
index 0c56692..43a3f16 100644
--- a/shell_client/src/client.rs
+++ b/shell_client/src/client.rs
@@ -1,53 +1,36 @@
-use rustyline::{error::ReadlineError, DefaultEditor};
+use crate::{autocomplete_reader::AutoCompleteReader, sys::get_process_list};
 use shell_core::*;
 use std::{
-    io::Write,
     os::unix::net::UnixStream,
+    sync::{Arc, Mutex},
     thread::{sleep, spawn, JoinHandle},
     time::Duration,
 };
 
 pub struct Client {
-    prefix: String,
     cmd_channel: Option<UnixStream>,
     output_channel: Option<UnixStream>,
     copy_stdout: Option<JoinHandle<()>>,
+    reader: Arc<Mutex<Box<AutoCompleteReader>>>,
 }
 
+static DEFAULT_PS1: &str = "\x1B[33m>> \x1B[0m";
+
 impl Client {
     pub fn new() -> Client {
         Client {
-            prefix: ">> ".to_owned(),
             cmd_channel: None,
             output_channel: None,
             copy_stdout: None,
+            reader: AutoCompleteReader::new().unwrap(),
         }
     }
 
     fn find_process(&self, arg: &Argument) -> Vec<(String, u64)> {
-        let output = std::process::Command::new("ps")
-            .arg("-A")
-            .arg("-o")
-            .arg("pid,comm")
-            .output()
-            .map_err(|err| err.to_string())
-            .expect("ps error");
-
-        let mut result = Vec::new();
-        for line in String::from_utf8(output.stdout)
-            .map_err(|err| err.to_string())
-            .expect("invalid utf8")
-            .lines()
-        {
-            let sp = line.split_whitespace().collect::<Vec<&str>>();
-            if sp.len() != 2 {
-                continue;
-            }
-
-            if let Ok(pid) = sp[0].parse::<u64>() {
-                result.push((sp[1].to_string(), pid));
-            }
-        }
+        let result: Vec<(String, u64)> = get_process_list()
+            .into_iter()
+            .map(|(pid, name)| (name, pid.parse().unwrap()))
+            .collect();
 
         match arg {
             Argument::Str(name) => result
@@ -68,6 +51,10 @@ impl Client {
         )
     }
 
+    fn parse_auto_complete(line: &str) -> Vec<String> {
+        line.split_whitespace().map(|s| s.to_owned()).collect()
+    }
+
     fn pad(&mut self, args: &Vec<Argument>) -> Result<(), String> {
         if args.len() != 1 {
             return Err(format!("argument number error"));
@@ -91,6 +78,20 @@ impl Client {
         self.output_channel =
             Some(UnixStream::connect(&output_path).map_err(|err| err.to_string())?);
 
+        if let Some(c) = &self.cmd_channel {
+            self.reader
+                .lock()
+                .map_err(|err| err.to_string())?
+                .append_debug_command_complete_data(
+                    Client::parse_auto_complete(&read_line(
+                        &mut c.try_clone().map_err(|err| err.to_string())?,
+                    )?)
+                    .into_iter()
+                    .map(|x| (x.clone(), x.clone()))
+                    .collect(),
+                )
+        }
+
         let mut output_channel_copy = self
             .output_channel
             .as_ref()
@@ -102,7 +103,10 @@ impl Client {
             let _ = std::io::copy(&mut output_channel_copy, &mut std::io::stdout());
         }));
 
-        self.prefix = format!("{} >> ", pids[0].0);
+        self.reader
+            .lock()
+            .map_err(|err| err.to_string())?
+            .set_prompt(format!("\x1B[32m{} >> \x1B[0m", pids[0].0).as_str());
 
         Ok(())
     }
@@ -122,9 +126,7 @@ impl Client {
     pub fn run_custom_command(&mut self, line: &String) -> Result<(), String> {
         match self.cmd_channel {
             None => Err("not pad to process".to_owned()),
-            Some(ref mut cmd_channel) => cmd_channel
-                .write_all(line.as_bytes())
-                .map_err(|err| err.to_string()),
+            Some(ref mut cmd_channel) => write_line(cmd_channel, line),
         }
     }
 
@@ -132,44 +134,54 @@ impl Client {
         self.cmd_channel = None;
         self.output_channel = None;
         self.copy_stdout = None;
-        self.prefix = ">> ".to_owned();
+        self.reader
+            .lock()
+            .expect("lock reader failed")
+            .set_prompt(DEFAULT_PS1);
     }
 
-    pub fn run(&mut self) -> Result<(), String> {
-        let mut editor = DefaultEditor::new().map_err(|err| err.to_string())?;
+    fn init_reader(&mut self) -> Result<(), String> {
+        let mut r = self.reader.lock().map_err(|err| err.to_string())?;
+        r.set_prompt(DEFAULT_PS1);
+        r.set_debug_command_complete_data(vec![
+            ("exit".to_owned(), "exit".to_owned()),
+            ("pad".to_owned(), "pad".to_owned()),
+        ]);
 
+        Ok(())
+    }
+
+    pub fn run(&mut self) -> Result<(), String> {
+        self.init_reader()?;
         loop {
-            match editor.readline(&self.prefix) {
-                Ok(line) => {
-                    if line.is_empty() {
-                        continue;
-                    }
-                    let _ = editor.add_history_entry(line.as_str());
-                    if let Some((cmd, args)) = split_command(line.trim()) {
-                        if let Err(err) = self.run_builtin_command(&cmd, &parse_arguments(&args)) {
-                            match err.as_str() {
-                                "exit" => break,
-                                "custom" => {
-                                    if let Err(err) = self.run_custom_command(&line) {
-                                        println!("Error: {}", err);
-                                        self.npad()
-                                    }
-                                    sleep(Duration::from_millis(10));
-                                }
-                                _ => {
-                                    println!("Error: {}", err);
-                                }
+            let line: String;
+            {
+                line = self
+                    .reader
+                    .lock()
+                    .expect("lock reader failed")
+                    .read()
+                    .expect("read failed");
+            }
+            if line.is_empty() {
+                continue;
+            }
+            if let Some((cmd, args)) = split_command(line.trim()) {
+                if let Err(err) = self.run_builtin_command(&cmd, &parse_arguments(&args)) {
+                    match err.as_str() {
+                        "exit" => break,
+                        "custom" => {
+                            if let Err(err) = self.run_custom_command(&line) {
+                                println!("Error: {}", err);
+                                self.npad()
                             }
+                            sleep(Duration::from_millis(10));
+                        }
+                        _ => {
+                            println!("Error: {}", err);
                         }
                     }
                 }
-                Err(ReadlineError::Interrupted) | Err(ReadlineError::Eof) => {
-                    continue;
-                }
-                Err(err) => {
-                    println!("Error: {:?}", err);
-                    break;
-                }
             }
         }
 
diff --git a/shell_client/src/completer/mod.rs b/shell_client/src/completer/mod.rs
new file mode 100644
index 0000000..6478aff
--- /dev/null
+++ b/shell_client/src/completer/mod.rs
@@ -0,0 +1,95 @@
+//! 完成器抽象
+mod pad_completer;
+mod path_completer;
+mod ushell_completer;
+
+pub use pad_completer::*;
+pub use path_completer::*;
+pub use ushell_completer::*;
+
+use linefeed::terminal::DefaultTerminal;
+use linefeed::Completion;
+use linefeed::Suffix;
+
+use crate::tools;
+
+/// 完成器
+/// - filter 是否满足当前完成器的激活条件
+/// - new 创建完成器
+pub trait Completer: linefeed::complete::Completer<DefaultTerminal> {
+    fn filter(w: &str, b: &str) -> bool
+    where
+        Self: Sized;
+    fn new() -> Box<dyn Completer>
+    where
+        Self: Sized;
+}
+
+/// 生成自动完成条目
+/// cmp_data 自动完成数据
+/// word 输入
+pub fn gen_autocomplete_item(
+    cmp_data: &Vec<(String, String)>,
+    word: &str,
+) -> Option<Vec<Completion>> {
+    let ops: Vec<Box<dyn Fn(&(String, String), &str) -> i32>> = vec![
+        Box::new(|x: &(String, String), word: &str| -> i32 {
+            if tools::is_prefix(&x.0, word) {
+                0
+            } else {
+                -1
+            }
+        }),
+        Box::new(|x: &(String, String), word: &str| -> i32 {
+            if tools::is_prefix(&x.1, word) {
+                1
+            } else {
+                -1
+            }
+        }),
+        Box::new(|x: &(String, String), word: &str| -> i32 {
+            if tools::is_prefix_nocase(&x.0, word) {
+                0
+            } else {
+                -1
+            }
+        }),
+        Box::new(|x: &(String, String), word: &str| -> i32 {
+            if tools::is_prefix_nocase(&x.1, word) {
+                1
+            } else {
+                -1
+            }
+        }),
+        Box::new(|x: &(String, String), word: &str| -> i32 {
+            if tools::contain_nocase(&x.1, word) {
+                1
+            } else {
+                -1
+            }
+        }),
+    ];
+    for op in ops {
+        let col: Vec<Completion> = cmp_data
+            .iter()
+            .filter_map(|x| match op(&x, &word) {
+                0 => Some(Completion {
+                    completion: x.0.clone(),
+                    display: Some(format!("{}({})", x.0, x.1)),
+                    suffix: Suffix::Default,
+                }),
+                1 => Some(Completion {
+                    completion: x.1.clone(),
+                    display: Some(format!("{}({})", x.0, x.1)),
+                    suffix: Suffix::Default,
+                }),
+                _ => None,
+            })
+            .collect();
+        if col.is_empty() {
+            continue;
+        }
+        return Some(col);
+    }
+    return None;
+}
diff --git a/shell_client/src/completer/pad_completer.rs b/shell_client/src/completer/pad_completer.rs
new file mode 100644
index 0000000..4642a1d
--- /dev/null
+++ b/shell_client/src/completer/pad_completer.rs
@@ -0,0 +1,32 @@
+//! pad 命令的完成器，用于完成进程列表
+use linefeed::{complete::Completion, prompter::Prompter, terminal::DefaultTerminal};
+
+use crate::{completer::Completer, sys};
+
+pub struct PadCommandCompleter;
+
+impl linefeed::complete::Completer<DefaultTerminal> for PadCommandCompleter {
+    fn complete(
+        &self,
+        word: &str,
+        _prompter: &Prompter<DefaultTerminal>,
+        _start: usize,
+        _end: usize,
+    ) -> Option<Vec<Completion>> {
+        crate::completer::gen_autocomplete_item(&sys::get_process_list(), &word)
+    }
+}
+
+impl Completer for PadCommandCompleter {
+    fn filter(_w: &str, b: &str) -> bool {
+        b.split_whitespace()
+            .map(|x| x.trim().to_owned())
+            .next()
+            .unwrap_or("".to_owned())
+            == "pad"
+    }
+
+    fn new() -> Box<dyn Completer> {
+        Box::new(PadCommandCompleter)
+    }
+}
diff --git a/shell_client/src/completer/path_completer.rs b/shell_client/src/completer/path_completer.rs
new file mode 100644
index 0000000..e1eaaae
--- /dev/null
+++ b/shell_client/src/completer/path_completer.rs
@@ -0,0 +1,31 @@
+//! 路径完成器
+use crate::completer::Completer;
+
+use linefeed::{complete::Completion, DefaultTerminal, Prompter};
+
+pub struct PathCompleter {
+    pub inner: linefeed::complete::PathCompleter,
+}
+
+impl Completer for PathCompleter {
+    fn filter(w: &str, b: &str) -> bool {
+        w.trim() != b.trim()
+    }
+    fn new() -> Box<dyn Completer> {
+        Box::new(PathCompleter {
+            inner: linefeed::complete::PathCompleter,
+        })
+    }
+}
+
+impl linefeed::complete::Completer<DefaultTerminal> for PathCompleter {
+    fn complete(
+        &self,
+        word: &str,
+        prompter: &Prompter<DefaultTerminal>,
+        start: usize,
+        end: usize,
+    ) -> Option<Vec<Completion>> {
+        self.inner.complete(word, prompter, start, end)
+    }
+}
diff --git a/shell_client/src/completer/ushell_completer.rs b/shell_client/src/completer/ushell_completer.rs
new file mode 100644
index 0000000..53c9ef2
--- /dev/null
+++ b/shell_client/src/completer/ushell_completer.rs
@@ -0,0 +1,98 @@
+//! ushell完成器，集成了一套完成器链，经过过滤后形成适合的完成建议
+use std::{
+    cell::Cell,
+    sync::{Arc, Mutex},
+};
+
+use crate::{
+    completer::{Completer, PadCommandCompleter, PathCompleter},
+    tools,
+};
+
+use linefeed::{
+    complete::{Completion, Suffix},
+    DefaultTerminal, Prompter,
+};
+
+pub struct UshellCompleter {
+    pub autocomplete_data: Mutex<Cell<Vec<(String, String)>>>,
+    pub completer_chain: Vec<(fn(&str, &str) -> bool, Box<dyn Completer>)>,
+}
+
+impl linefeed::complete::Completer<DefaultTerminal> for UshellCompleter {
+    fn complete(
+        &self,
+        word: &str,
+        prompter: &Prompter<DefaultTerminal>,
+        start: usize,
+        end: usize,
+    ) -> Option<Vec<Completion>> {
+        self.completer_chain
+            .iter()
+            .filter(|x| x.0(&word.to_string(), &prompter.buffer().trim().to_string()))
+            .find_map(|c| match c.1.complete(word, prompter, start, end) {
+                Some(x) => {
+                    if !x.is_empty() {
+                        Some(x)
+                    } else {
+                        None
+                    }
+                }
+                None => None,
+            })
+            .map_or_else(|| self.debug_command_complete(word), |x| Some(x))
+    }
+}
+
+impl UshellCompleter {
+    pub fn debug_command_complete(&self, word: &str) -> Option<Vec<Completion>> {
+        for cmp in [
+            tools::is_prefix,
+            tools::is_prefix_nocase,
+            tools::contain_nocase,
+        ] {
+            let ret = self
+                .autocomplete_data
+                .lock()
+                .expect("lock autocomplete data failed")
+                .get_mut()
+                .iter()
+                .filter(|x| cmp(&x.0, word))
+                .map(|x| Completion {
+                    completion: x.0.clone(),
+                    display: Some(x.1.clone()),
+                    suffix: Suffix::Default,
+                })
+                .collect::<Vec<Completion>>();
+            if ret.len() != 0 {
+                return Some(ret);
+            }
+        }
+        None
+    }
+
+    pub fn set_autocomplete_data(&self, data: Vec<(String, String)>) {
+        self.autocomplete_data
+            .lock()
+            .expect("lock autocomplete data failed")
+            .set(data);
+    }
+
+    pub fn append_complete_data(&self, data: Vec<(String, String)>) {
+        let mut data = data;
+        data.append(
+            self.autocomplete_data
+                .lock()
+                .expect("lock autocomplete data failed")
+                .get_mut(),
+        );
+        self.set_autocomplete_data(data);
+    }
+
+    pub fn new() -> Arc<UshellCompleter> {
+        Arc::new(UshellCompleter {
+            autocomplete_data: Mutex::new(Cell::new(Vec::new())),
+            completer_chain: crate::reg_completer!(PadCommandCompleter, PathCompleter),
+        })
+    }
+}
diff --git a/shell_client/src/lib.rs b/shell_client/src/lib.rs
index be50984..a69ef7e 100644
--- a/shell_client/src/lib.rs
+++ b/shell_client/src/lib.rs
@@ -1,3 +1,6 @@
+mod autocomplete_reader;
 mod client;
-
+mod completer;
+mod sys;
+mod tools;
 pub use client::*;
diff --git a/shell_client/src/sys.rs b/shell_client/src/sys.rs
new file mode 100644
index 0000000..ce28ddc
--- /dev/null
+++ b/shell_client/src/sys.rs
@@ -0,0 +1,34 @@
+/*!
+ * 系统功能封装
+ */
+
+use lazy_static::lazy_static;
+use regex::Regex;
+use std::process;
+
+lazy_static! {
+    static ref RE_PROCNAME: Regex = Regex::new(r"Name:\s(.*)").unwrap();
+}
+
+/// 获取进程列表
+pub fn get_process_list() -> Vec<(String, String)> {
+    lazy_static! {
+        static ref PS_RE: Regex = Regex::new(r"(\d+)(\s+[^\s]+){2}\s+([^\s].*)").unwrap();
+    }
+
+    String::from_utf8(
+        process::Command::new("ps")
+            .args(["-A"])
+            .output()
+            .unwrap()
+            .stdout,
+    )
+    .expect("decode failed")
+    .split("\n")
+    .skip(1)
+    .filter_map(|x| match PS_RE.captures(x) {
+        Some(sp) => Some((sp[1].to_string(), sp[3].to_string())),
+        None => None,
+    })
+    .collect()
+}
diff --git a/shell_client/src/tools.rs b/shell_client/src/tools.rs
new file mode 100644
index 0000000..f788fc3
--- /dev/null
+++ b/shell_client/src/tools.rs
@@ -0,0 +1,22 @@
+/*!
+ * 工具
+ */
+
+/// 判断一个字符串是否是另一个字符串的前缀
+pub fn is_prefix(src: &str, prefix: &str) -> bool {
+    src.len() >= prefix.len() && prefix == &src[..prefix.len()]
+}
+
+/// 判断一个字符串是否是另一个字符串的前缀，忽略大小写
+pub fn is_prefix_nocase(src: &str, prefix: &str) -> bool {
+    src.len() >= prefix.len() && prefix.to_uppercase() == src[0..prefix.len()].to_uppercase()
+}
+
+/// 判断一个字符串是否是另一个字符串的子串，忽略大小写
+pub fn contain_nocase(src: &str, substr: &str) -> bool {
+    src.len() >= substr.len()
+        && src
+            .to_uppercase()
+            .find(&substr.to_uppercase())
+            .map_or(false, |_| true)
+}
diff --git a/shell_core/src/lib.rs b/shell_core/src/lib.rs
index 82abd33..4be2675 100644
--- a/shell_core/src/lib.rs
+++ b/shell_core/src/lib.rs
@@ -1,4 +1,7 @@
-use std::fmt::Display;
+use std::{
+    fmt::Display,
+    io::{Read, Write},
+};
 
 #[derive(Debug)]
 pub enum Argument {
@@ -15,6 +18,31 @@ impl Display for Argument {
     }
 }
 
+pub fn read_line<T: Read>(conn: &mut T) -> Result<String, String> {
+    let mut buf = vec![];
+    let mut tmp_buf = [0u8; 4096];
+    loop {
+        let sz = conn.read(&mut tmp_buf).map_err(|err| err.to_string())?;
+        if sz == 0 {
+            return Err("connection closed".to_string());
+        }
+        buf.extend_from_slice(&tmp_buf[0..sz]);
+        if buf.ends_with(&[b'\n']) {
+            break;
+        }
+    }
+
+    Ok(String::from_utf8(buf)
+        .map_err(|err| err.to_string())?
+        .trim()
+        .to_owned())
+}
+
+pub fn write_line<T: Write>(conn: &mut T, line: &String) -> Result<(), String> {
+    conn.write_all((line.to_owned() + "\n").as_bytes())
+        .map_err(|err| err.to_string())
+}
+
 pub fn parse_arguments(input: &str) -> Vec<Argument> {
     let mut result = Vec::new();
     let mut current_arg = String::new();
diff --git a/shell_server/src/server.rs b/shell_server/src/server.rs
index 285ef95..86b1269 100644
--- a/shell_server/src/server.rs
+++ b/shell_server/src/server.rs
@@ -8,6 +8,7 @@ use std::{
 };
 
 use libc::{c_int, close, dup, dup2, STDOUT_FILENO};
+use shell_core::{read_line, write_line};
 
 use crate::shell::Shell;
 
@@ -34,10 +35,9 @@ impl Server {
     }
 
     fn handle_cmd_connect(mut conn: UnixStream, shell: Shell) -> Result<(), String> {
-        let mut buf: [u8; 1024] = [0; 1024];
+        let _ = write_line(&mut conn, &shell.get_reg_commands().join(" "))?;
         loop {
-            let sz = conn.read(&mut buf).map_err(|err| err.to_string())?;
-            let s = String::from_utf8(buf[0..sz].to_vec()).map_err(|err| err.to_string())?;
+            let s = read_line(&mut conn)?;
             if let Err(err) = shell.run_command(&s) {
                 println!("Error: {}", err);
             }
diff --git a/shell_server/src/shell.rs b/shell_server/src/shell.rs
index 50d10c6..599e63a 100644
--- a/shell_server/src/shell.rs
+++ b/shell_server/src/shell.rs
@@ -22,6 +22,10 @@ impl Shell {
         }
     }
 
+    pub fn get_reg_commands(&self) -> Vec<String> {
+        self.func_map.keys().map(|k| k.to_string()).collect()
+    }
+
     pub fn reg_func(&mut self, name: String, addr: u64) {
         self.func_map.insert(name, addr);
     }
@@ -65,7 +69,10 @@ impl Shell {
                 };
             }
 
-            println!("[begin to excel func {}]", command);
+            println!(
+                "\x1B[34m------------[begin to excel func {}]------------\x1B[0m",
+                command
+            );
             if let Ok(ret) = match argument_int64.len() {
                 0 => call_func!(create_fn_0),
                 1 => call_func!(create_fn_1, 0),
@@ -80,7 +87,10 @@ impl Shell {
                 10 => call_func!(create_fn_10, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9),
                 _ => Err("too many arguments".to_string()),
             } {
-                println!("[end to excel func {}]:{}", command, ret);
+                println!(
+                    "\x1B[35m------------[end to excel func {}]:{}------------\x1B[0m",
+                    command, ret
+                );
             }
             Ok(())
         })
